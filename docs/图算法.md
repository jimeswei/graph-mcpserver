1、Louvain
2、pagerank
3、Dijkstra/BFS 
4、Node2Vec/DeepWalk
## Java 实现图算法及单元测试

下面将简要介绍如何在 Java 中实现上述图算法，并提供单元测试的思路。

### 1. Louvain 算法

**Java 实现思路：**
*   **数据结构：** 使用邻接表或邻接矩阵表示图。需要存储节点的社区归属、边的权重等信息。
*   **核心逻辑：**
    1.  **初始化：** 每个节点初始时属于一个独立的社区。
    2.  **迭代优化：**
        *   遍历每个节点 `i`。
        *   对于节点 `i` 的每个邻居 `j` 所在的社区 `C`，计算将节点 `i` 移动到社区 `C` 后的模块度增益 `ΔQ`。
        *   将节点 `i` 移动到使其 `ΔQ` 最大且为正的社区。
        *   重复此过程，直到没有节点的移动可以增加模块度，或者达到最大迭代次数。
    3.  **网络重构：** 将第一阶段形成的社区视为新的节点，构建新的网络。边的权重为原始网络中社区间连接的权重之和。
    4.  重复步骤 2 和 3，直到整个网络的模块度不再显著提高。

**单元测试思路：**
*   **小规模已知图：** 准备一些节点和边较少，且社区结构已知的图。
*   **验证社区划分：** 运行 Louvain 算法，验证输出的社区划分是否与预期一致。
*   **模块度计算：** 单独测试模块度计算函数的正确性。
*   **边界条件：** 测试空图、单个节点的图、完全图等。

### 2. PageRank 算法

**Java 实现思路：**
*   **数据结构：** 邻接表存储图结构，`Map<Node, Double>` 存储每个节点的 PageRank 值。
*   **核心逻辑（迭代法）：**
    1.  **初始化：** 为所有节点分配初始 PageRank 值（例如，`1/N`，其中 `N` 是节点总数）。
    2.  **迭代计算：**
        *   对于每个节点 `u`，其新的 PageRank 值计算公式为：
            `PR(u) = (1-d)/N + d * Σ (PR(v) / L(v))`
            其中：
            *   `d` 是阻尼系数（通常为 0.85）。
            *   `N` 是图中节点的总数。
            *   `v` 是指向节点 `u` 的节点。
            *   `L(v)` 是节点 `v` 的出度。
        *   处理悬挂节点（没有出链的节点）：可以认为它们链接到所有其他节点，或者将它们的 PageRank 值平均分配给所有节点。
    3.  **收敛判断：** 当所有节点的 PageRank 值变化小于某个阈值，或者达到最大迭代次数时，停止迭代。

**单元测试思路：**
*   **简单图结构：**
    *   两个节点互相链接。
    *   三个节点形成环。
    *   星型图。
*   **验证 PageRank 值：** 对于简单图，可以手动计算预期的 PageRank 值，并与算法输出进行比较。
*   **悬挂节点处理：** 测试包含悬挂节点的图，验证其 PageRank 值是否按预期分配。
*   **收敛性：** 监控迭代过程中 PageRank 值的变化，确保算法能够收敛。

### 3. Dijkstra 算法 / BFS 算法

#### Dijkstra 算法 (单源最短路径 - 带权图)

**Java 实现思路：**
*   **数据结构：**
    *   邻接表表示图，存储边的权重。
    *   `PriorityQueue` 存储待访问的节点，按到源节点的距离排序。
    *   `Map<Node, Double>` 存储源节点到各节点的最短距离。
    *   `Map<Node, Node>` 存储最短路径上的前驱节点，用于路径回溯。
*   **核心逻辑：**
    1.  **初始化：** 源节点距离设为 0，其他节点距离设为无穷大。将源节点加入优先队列。
    2.  **迭代：**
        *   从优先队列中取出距离最小的节点 `u`。
        *   对于 `u` 的每个邻居 `v`：
            *   如果通过 `u` 到达 `v` 的路径比当前已知的到 `v` 的最短路径更短 (`dist[u] + weight(u,v) < dist[v]`)，则更新 `dist[v]` 和 `v` 的前驱节点，并将 `v` 加入（或更新其在）优先队列中的位置。
    3.  重复直到优先队列为空，或找到目标节点。

**单元测试思路：**
*   **不同图结构：** 线性图、环形图、网格图、包含负权边（Dijkstra 不适用，但可测试其行为或抛出异常）。
*   **验证最短路径长度：** 对比算法计算的路径长度与手动计算或已知的最短路径长度。
*   **验证路径本身：** 回溯前驱节点，验证路径的正确性。
*   **不可达节点：** 测试源节点无法到达目标节点的情况。
*   **自环和重边：** 测试包含自环和重边的图。

#### BFS 算法 (单源最短路径 - 无权图)

**Java 实现思路：**
*   **数据结构：**
    *   邻接表表示图。
    *   `Queue` (如 `LinkedList`) 存储待访问的节点。
    *   `Map<Node, Integer>` 存储源节点到各节点的距离（层数）。
    *   `Set<Node>` 或 `boolean[]` 标记已访问节点。
    *   `Map<Node, Node>` 存储最短路径上的前驱节点。
*   **核心逻辑：**
    1.  **初始化：** 源节点距离设为 0，加入队列，标记为已访问。
    2.  **迭代：**
        *   从队列中取出节点 `u`。
        *   对于 `u` 的每个未访问的邻居 `v`：
            *   标记 `v` 为已访问。
            *   设置 `dist[v] = dist[u] + 1`。
            *   设置 `v` 的前驱为 `u`。
            *   将 `v` 加入队列。
    3.  重复直到队列为空，或找到目标节点。

**单元测试思路：**
*   与 Dijkstra 类似，但针对无权图。
*   **验证层级/距离：** 确保 BFS 正确计算节点所在的层级（即到源点的最短边数）。
*   **连通分量：** BFS 可用于查找图中的连通分量，可以测试此功能。

### 4. Node2Vec / DeepWalk 算法

这类算法属于图嵌入（Graph Embedding）或网络表示学习（Network Representation Learning）的范畴，目标是将图中的节点表示为低维向量，同时保留图的结构信息。

**Java 实现思路：**
*   **DeepWalk:**
    1.  **随机游走：** 从图中的每个节点开始，执行多次固定长度的随机游走，生成节点序列（类似于句子）。
    2.  **Skip-gram 模型：** 将随机游走生成的节点序列视为语料库，使用类似于 Word2Vec 中的 Skip-gram 模型学习节点向量。即，给定一个中心节点，预测其在游走序列中上下文窗口内的邻居节点。
*   **Node2Vec:**
    *   对 DeepWalk 的随机游走策略进行了改进，引入了两个参数 `p` 和 `q` 来控制游走的倾向性：
        *   `p` (Return parameter): 控制立即返回上一节点的概率。
        *   `q` (In-out parameter): 控制游走向更远节点（探索性）还是更近节点（局部性）的概率。
    *   通过调整 `p` 和 `q`，Node2Vec 可以捕捉到图的不同结构特性（同质性 vs. 结构对等性）。
    *   后续步骤与 DeepWalk 类似，使用 Skip-gram 模型学习节点嵌入。

**Java 实现挑战：**
*   直接用纯 Java 实现 Skip-gram 模型较为复杂，通常会依赖现有的机器学习库（如 DL4J - Deep Learning for Java）或调用 Python 的相关库（如 Gensim）。
*   核心在于实现高效的随机游走生成器，特别是 Node2Vec 中带偏置的随机游走。

**单元测试思路：**
*   **随机游走生成：**
    *   测试游走序列的长度是否符合预期。
    *   对于 Node2Vec，验证参数 `p` 和 `q` 是否正确影响游走概率。例如，设置 `p` 很高时，游走倾向于返回；设置 `q` 很高时，游走倾向于探索未访问过的邻居。
*   **嵌入向量生成：**
    *   验证是否为图中所有节点都生成了向量。
    *   验证向量维度是否符合配置。
*   **定性评估（较难自动化）：**
    *   在已知结构的小图上运行，观察相似节点的向量是否在向量空间中也相近（例如，通过计算余弦相似度）。
    *   例如，在 Zachary's Karate Club 数据集上，观察属于同一社区的节点嵌入是否更相似。
*   **下游任务性能：** 更实际的测试是通过在下游任务（如节点分类、链接预测）上评估生成的嵌入向量的性能，但这超出了单元测试的范畴，更接近集成测试或评估。

**通用建议：**
*   **图表示：** 选择合适的图数据结构（邻接表、邻接矩阵）。对于稀疏图，邻接表通常更优。
*   **辅助类：** 创建 `Node` 和 `Edge` 类来清晰地表示图的元素。
*   **模块化：** 将算法的不同部分（如初始化、迭代、结果提取）封装到不同的方法或类中。
*   **测试覆盖率：** 尽量覆盖各种边界情况和典型的图结构。
*   **性能考虑：** 对于大规模图，需要关注算法的时间和空间复杂度。

### Java代码实现
Java项目中组织和实现这些图算法的结构性概览。这些代码片段旨在展示核心类和方法的框架，具体的实现细节和完整的错误处理、优化等需要根据实际项目需求进行填充。

#### 0. 基础图数据结构 (Basic Graph Data Structures)

这些是构建图算法所需的基础类。通常会放在项目的核心模块中，例如 `com.example.graph.core` 包下。

##### Node.java



























